diff --git a/include/uc_priv.h b/include/uc_priv.h
index e4174f98..821fde3c 100644
--- a/include/uc_priv.h
+++ b/include/uc_priv.h
@@ -284,6 +284,14 @@ struct uc_struct {
     // util/cacheinfo.c
     int qemu_icache_linesize;
     int qemu_dcache_linesize;
+
+    // AFL++-Unicorn Mode
+    unsigned char *afl_area_ptr;
+    int afl_compcov_level;
+    unsigned int afl_inst_rms; 
+    int afl_forkserver_installed; // 0 if no forserver (yet)
+    int afl_forkserver_pid; 
+    void *afl_prev_loc; // the last basic block executed
 };
 
 // Metadata stub for the variable-size cpu context used with uc_context_*()
diff --git a/qemu/accel/tcg/cpu-exec.c b/qemu/accel/tcg/cpu-exec.c
index ab095e75..51a2d05e 100644
--- a/qemu/accel/tcg/cpu-exec.c
+++ b/qemu/accel/tcg/cpu-exec.c
@@ -32,6 +32,10 @@
 
 #include "uc_priv.h"
 
+#include "../../patches/afl-unicorn-cpu-inl.h"
+
+static int afl_first_insn = 0;
+
 /* Execute a TB, and fix up the CPU state afterwards if necessary */
 static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)
 {
@@ -42,6 +46,8 @@ static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)
     int tb_exit;
     uint8_t *tb_ptr = itb->tc.ptr;
 
+    AFL_QEMU_CPU_SNIPPET2;
+
     ret = tcg_qemu_tb_exec(env, tb_ptr);
     cpu->can_do_io = 1;
     last_tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);
@@ -211,6 +217,7 @@ static inline TranslationBlock *tb_find(CPUState *cpu,
     TranslationBlock *tb;
     target_ulong cs_base, pc;
     uint32_t flags;
+    bool was_translated = false, was_chained = false;
     bool acquired_tb_lock = false;
 
     tb = tb_lookup__cpu_state(cpu, &pc, &cs_base, &flags, cf_mask);
@@ -226,6 +233,7 @@ static inline TranslationBlock *tb_find(CPUState *cpu,
         if (likely(tb == NULL)) {
             /* if no translated code available, then translate it now */
             tb = tb_gen_code(cpu, pc, cs_base, flags, cf_mask);
+            was_translated = true;
         }
 
         mmap_unlock();
@@ -253,12 +261,16 @@ static inline TranslationBlock *tb_find(CPUState *cpu,
             cpu->tb_flushed = false;
         } else if (!(tb_cflags(tb) & CF_INVALID)) {
             tb_add_jump(last_tb, tb_exit, tb);
+            was_chained = true;
         }
     }
     if (acquired_tb_lock) {
         // Unicorn: commented out
         //tb_unlock();
     }
+    if (was_translated || was_chained) {
+        afl_request_tsl(pc, cs_base, flags, cf_mask, was_chained ? last_tb : NULL, tb_exit);
+    }
     return tb;
 }
 
diff --git a/qemu/accel/tcg/translate-all.c b/qemu/accel/tcg/translate-all.c
index 78fb15f1..7004fc4b 100644
--- a/qemu/accel/tcg/translate-all.c
+++ b/qemu/accel/tcg/translate-all.c
@@ -61,6 +61,8 @@
 
 #include "uc_priv.h"
 
+#include "../../../../patches/afl-unicorn-translate-inl.h"
+
 /* #define DEBUG_TB_INVALIDATE */
 /* #define DEBUG_TB_FLUSH */
 /* make various TB consistency checks */
@@ -1374,6 +1376,7 @@ TranslationBlock *tb_gen_code(CPUState *cpu,
     tcg_func_start(tcg_ctx);
 
     tcg_ctx->cpu = env_cpu(env);
+    afl_gen_trace(env->uc, pc);
     gen_intermediate_code(cpu, tb, max_insns);
     tcg_ctx->cpu = NULL;
 
diff --git a/qemu/accel/tcg/translator.c b/qemu/accel/tcg/translator.c
index d9eea7a7..90d7782e 100644
--- a/qemu/accel/tcg/translator.c
+++ b/qemu/accel/tcg/translator.c
@@ -53,6 +53,7 @@ void translator_loop(const TranslatorOps *ops, DisasContextBase *db,
     /* Reset the temp count so that we can identify leaks */
     tcg_clear_temp_count();
 
+    //TODO: why did I put this here: afl_gen_trace(tcg_ctx, tb->pc)
     /* Unicorn: early check to see if the address of this block is
      * the "run until" address. */
     if (tb->pc == cpu->uc->addr_end) {
